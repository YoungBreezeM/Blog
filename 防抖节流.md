## 防抖节流

####    在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果

### 防抖函数

####    函数防抖（debounce）：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。

防抖代码

```javascript
/**
 * fun 防抖执行函数
 * */
const debounce = (fun, delay = 2000) => {
    let timer = null ;//设定一个定时器
    return function (...args) {
        clearTimeout(timer);
        timer = setTimeout(() => {
            fun.apply(this, args)
        }, delay)
    }
};
```

完整的代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<button id="login">点击</button>

</body>
<script>
    /**
     * fun 防抖执行函数
     * */
    const debounce = (fun, delay = 2000) => {
        let timer = null ;//设定一个定时器
        return function (...args) {
            clearTimeout(timer);
            timer = setTimeout(() => {
                fun.apply(this, args)
            }, delay)
        }
    };

    let handle = function () {
        console.log(Math.random());

    };

    document.getElementById("login").addEventListener('click', debounce(handle, 1000));

</script>
</html>
```

设置一个定时器，当有新的事件被触发的时候，原来的定时器就会被清除，生成一个新的定时器。这样就会产生一个弊端，如果用户不断触发事件，那么就会无法完成这个过程，下面看看另一种做法，节流。

#### 节流函数

当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。

节流代码

```javascript
/**
* func 节流代码执行函数
*/
const throttle = function(func, delay) {
    let timer = null;
    return function() {
        let context = this;
        let args = arguments;
        if (!timer) {
            timer = setTimeout(function() {
                func.apply(context, args);
                timer = null;
            }, delay);
        }
    }
};
```

完整的代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<button id="login">点击</button>

</body>
<script>
    /**
     * fun 防抖执行函数
     * */
    const debounce = (fun, delay = 2000) => {
        let timer = null ;//设定一个定时器
        return function (...args) {
            clearTimeout(timer);
            timer = setTimeout(() => {
                fun.apply(this, args)
            }, delay)
        }
    };

    const throttle = function(func, delay) {
        let timer = null;
        return function() {
            let context = this;
            let args = arguments;
            if (!timer) {
                timer = setTimeout(function() {
                    func.apply(context, args);
                    timer = null;
                }, delay);
            }
        }
    };

    let handle = function () {
        console.log(Math.random());

    };

    document.getElementById("login").addEventListener('click', throttle(handle, 1000));

</script>
</html>
```

当触发事件的时候，我们设置一个定时器，再次触发事件的时候，如果定时器存在，就不执行，直到delay时间后，定时器执行执行函数，并且清空定时器，这样就可以设置下个定时器。当第一次触发事件时，不会立即执行函数，而是在delay秒后才执行。而后再怎么频繁触发事件，也都是每delay时间才执行一次。当最后一次停止触发后，由于定时器的delay延迟，可能还会执行一次函数。